# Почему getElementById и querySelector в React - плохо
## [1. Два подхода в программировании](#1-два-подхода-в-программировании-1)
## [2. Полный контроль — сами следим за всем](#2-полный-контроль--сами-следим-за-всем-1)
## [3. Неправильная реализация через React](#3-неправильная-реализация-через-react-1)
## [4. Пусть за нас все делает React](#4-пусть-за-нас-все-делает-react-1)

Данный курс в полном объеме:
- все материалы
- коды уроков
- домашнее задание
- поддержка
- помощь в решении и разборе дз
- проверка дз и перепроверка

доступен тем, кто приобрел курс [React.js](https://itgid.info/course/reactjs)

_Текущий юнит написан на React v18._

## 1. Два подхода в программировании

Сейчас я приведу три абзаца, которые нужно привести. Сразу скажу — я против таких определений, и дальше объясню все простыми словами. Итак, прошу прощения заранее.

> Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.

> К примеру, в императивном программировании присваивание a = b + c будет означать, что переменной a будет присвоен результат выполнения операции b + c, используя текущие (на момент вычисления) значения переменных. Позже значения переменных b и c могут быть изменены без какого-либо влияния на значение переменной a.

> В реактивном же программировании значение a будет автоматически пересчитано, основываясь на новых значениях.

Все, ужас закончился. Теперь объясняю. Название React подразумевает, что идеология библиотеки строится на реактивном подходе. Что такое реактивный подход? Смотрите, допустим есть простая задача — вывести сумму переменных. Как будет выглядеть код в “обычном” написании?

```javascript
 let a = 5;
 let b = 6;
 let c = a + b;
 console.log(c); // 11
```

Тут все понятно — в консоли будет 11. Кстати, “обычный” подход это императивный подход. Давайте доработаем код:

```javascript
 let a = 5;
 let b = 6;
 let c = a + b;
 console.log(c); // 11
 a = 7;
 console.log(c); // 11
```

В императивном подходе то, что мы присвоили ``a`` новое значение не влияет на ``с``. Ведь операция выполнена после суммирования. Такой подход понятен, мы с ним работали все курсы до этого.

Совершенно другую идею несет реактивный подход. Я не хочу пересказывать идеи реактивного программирования, только обрисую концепции. Есть состояния и связи. При изменении состояний, все от них зависящие состояния — обновятся. При таком подходе подобный код выполнится так:

```javascript
 let a = 5;
 let b = 6;
 let c = a + b;
 console.log(c); // 11
 a = 7;
 console.log(c); // 13
```

Т.е. поскольку состояние c зависит от ``a``, ``b`` то обновление ``a = 7`` приведет к пересчету ``с``. Нам не нужно руками делать операцию по суммированию снова.

Давайте разберемся более подробно в этих подходах.

## 2. Полный контроль — сами следим за всем

Давайте реализуем задачу — форма, куда пользователь может ввести 2 числа. После нажатия кнопки, выводим сумму чисел. Решаем нативно — через JavaScript. HTML код:

```html
<form>
  <input type="number" name="num1">
  <input type="number" name="num2">
  <input type="submit" value="Sum">
</form>
<div class="out"></div>
```
и JS код:

```javascript
document.querySelector('form').addEventListener('submit', function(event){
  event.preventDefault();
	
  // получаем num1
  let num1 = +event.target.elements.num1.value;
  // получаем num2
  let num2 = +event.target.elements.num2.value;
	
  // выводим
  document.querySelector('.out').textContent = num1 + num2;
});
```
Скачать и запустить код (unit_06_code_01). Обратите внимание на важный момент — нам все равно что лежит в ``out``. Даже начальное значение не прописано. Мы об этом не заботимся. Блок ``out`` никак не связан с формой — эту связь контролируем мы, через код.

Убедитесь, что все работает. Давайте теперь реализуем неправильный подход в решении, через **React**.

## 3. Неправильная реализация через React

Напоминаю! **Сейчас я покажу очень неправильный код. Он приведен только для того, чтобы понять что так делать нельзя!**

```javascript
function App() {

const formHandler = (event) => {
  event.preventDefault();
	
  let num1 = +document.querySelector('.num1').value;
  let num2 = +document.querySelector('.num2').value;
	
  document.querySelector('.out').innerHTML = num1 + num2;
}

return (
  <div className="App">
    <form onSubmit={formHandler}>
      <input type="number" className ="num1" />
      <input type="number" className ="num2" />
      <input type="submit" value = "Sum" />
    </form>
    <div className ="out"></div>
  </div>
);
}
```

Скачать и запустить код (unit_06_code_02). Обратите внимание — код работает. Я очень не люблю эти слова, которые преследуют меня все курсы. А именно **“какой тут баг? Ведь все работает”**. В данном случае — да, код работает, но с точки зрения и идеологии **React** код абсолютно не корректный. Почему работает — потому что это JavaScript. Почему не корректный — потому что полностью игнорирует реактивный подход. Поэтому запоминаем — никаких getElementById, querySelector… и прямого обращения к DOM. А как писать? Переходим к следующей главе.

## 4. Пусть за нас все делает React

Очень хочу чтобы вы поняли, приложения **React** нельзя писать так: набросали интерфейс, подправили, написали код, что-то подправили, заработало... Такой подход очень плох если вы хотите реактивное приложение. Любое приложение **React**, любой компонент нужно начинать с анализа. Определим те данные, которые определяют работу приложения.

Переменные ``num1``, ``num2`` – а правильнее сказать, данные что введены в ``input``. Т.е. у нас будут **state**, которые определяют введенные данные. Как только мы отвлекаемся от кода, сразу вопрос — а чему равны эти данные в начальный момент? Как видите, подобное рассуждение очень полезны. Давайте напишем код приложения отталкиваясь от данных. Для начала определим стейты.

```javascript
function App() {

  const [a, setA] = useState(0); // определили начальное значение и тип
  const [b, setB] = useState(0); // определили начальное значение и тип
```

этих данных достаточно чтобы полностью описать состояние компонента. Теперь добавим код:

```javascript
function App() {

  const [a, setA] = useState(0); // определили начальное значение и тип
  const [b, setB] = useState(0); // определили начальное значение и тип

  const formHandler = (event) => {
    event.preventDefault();
    setA(event.target.elements.num1.value);
    setB(event.target.elements.num2.value);
  }

 return (
  <div className="App">
    <form onSubmit={formHandler}>
        <input type="number" name ="num1" defaultValue={a}/>
        <input type="number" name ="num2" defaultValue={b} />
        <input type="submit" value = "Sum" />
    </form>
    <div className ="out">{a + b}</div>
  </div>
 );
}
```

Скачать и запустить код (unit_06_code_03). Обратите внимание, при таком подходе отпал целый ряд вопросов о начальном состоянии, о первоначальном выводе в out. Также вопрос о контроле обновления вывода — все это происходит автоматически, при обновлении данных.

Надеюсь вы поняли разницу идеологий подходов. В **React**, мы отталкивается от данных  (состояний) компонента, которые и определяют логику работы и внешний вид компонента. А в нативном JS – напрямую управляем любыми нужными элементами.

## Итог
**React**, к сожалению, позволяет обращение напрямую к DOM элементам и даже работает, но с точки зрения реактивного подхода не является корректным. Планируйте компонент с точки зрения состояний.
